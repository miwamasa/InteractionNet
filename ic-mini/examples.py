"""
Interaction Calculus Mini - 教育用例題集
==========================================

このファイルには、Interaction Calculusの概念を学ぶための
実用的な例題が含まれています。

実行方法:
    python examples.py

各例題は独立しており、概念ごとに整理されています。
"""

import sys
sys.path.insert(0, 'src')
from ic import evaluate, parse


def section(title: str):
    """セクションヘッダーを表示"""
    print("\n" + "=" * 60)
    print(f" {title}")
    print("=" * 60)


def example(name: str, code: str, explanation: str = "", debug: bool = False):
    """例題を実行して結果を表示"""
    print(f"\n📝 {name}")
    print(f"   コード: {code}")
    if explanation:
        print(f"   説明: {explanation}")
    result = evaluate(code, debug=debug)
    print(f"   結果: {result}")
    return result


def main():
    print("""
╔══════════════════════════════════════════════════════════════╗
║     Interaction Calculus Mini - 教育用例題集                  ║
╚══════════════════════════════════════════════════════════════╝
    """)

    # =========================================================================
    section("1. 基本：ラムダ計算")
    # =========================================================================
    
    example(
        "恒等関数 (Identity)",
        "(λx.x 42)",
        "入力をそのまま返す最もシンプルな関数"
    )
    
    example(
        "定数関数 (Constant)",
        "((λx.λy.x 100) 999)",
        "最初の引数を返し、2番目を無視する"
    )
    
    example(
        "関数合成",
        "((λf.λg.λx.(f (g x)) λa.(a + 1)) λb.(b * 2))",
        "(+1) と (*2) を合成。結果は λx.((x*2)+1)"
    )
    
    example(
        "合成関数の適用",
        "(((λf.λg.λx.(f (g x)) λa.(a + 1)) λb.(b * 2)) 5)",
        "5 → 5*2=10 → 10+1=11"
    )

    # =========================================================================
    section("2. 複製 (Duplication) - 値の共有")
    # =========================================================================
    
    example(
        "数値の複製",
        "! x &L= 7; (x_0 + x_1)",
        "7を複製して x₀=7, x₁=7 として使用 → 7+7=14"
    )
    
    example(
        "計算結果の共有",
        "! result &L= (10 + 20); (result_0 * result_1)",
        "10+20=30 を一度だけ計算し、30*30=900"
    )
    
    example(
        "三重使用（ネスト複製）",
        "! x &L= 5; ! y &R= x_0; ((x_1 + y_0) + y_1)",
        "5を3箇所で使用: 5 + 5 + 5 = 15"
    )

    # =========================================================================
    section("3. 重ね合わせ (Superposition) - 並列的な値")
    # =========================================================================
    
    example(
        "重ね合わせへの演算",
        "(&L{10, 20} + 5)",
        "{10, 20} の両方に +5 → {15, 25}"
    )
    
    example(
        "重ね合わせの展開",
        "! x &L= &L{100, 200}; (x_0, x_1)",
        "重ね合わせを分解: x₀=100, x₁=200"
    )
    
    example(
        "条件分岐のシミュレーション",
        "! branch &L= &L{1, 0}; ((branch_0 * 100) + (branch_1 * 50))",
        "true=1, false=0 として両方の結果を計算"
    )

    # =========================================================================
    section("4. 最適共有 - ラムダ内部での計算共有")
    # =========================================================================
    
    example(
        "ラムダの複製（基本）",
        "! f &L= λx.(x + 1); ((f_0 10), (f_1 20))",
        "同じ関数を2つの異なる引数に適用"
    )
    
    example(
        "ラムダ内の計算共有",
        "! f &L= λx.((2 + 3) * x); ((f_0 10), (f_1 100))",
        "(2+3)=5 は1回だけ計算され、5*10=50 と 5*100=500"
    )
    
    example(
        "高階関数の複製",
        "! twice &L= λf.λx.(f (f x)); ((twice_0 λa.(a + 1)) ((twice_1 λb.(b * 2)) 3))",
        "twice を2回使用: (+1を2回) と (*2を2回)"
    )

    # =========================================================================
    section("5. ラベルによる制御")
    # =========================================================================
    
    example(
        "同じラベル → 消滅",
        "! x &L= &L{1, 2}; (x_0 + x_1)",
        "ラベルLが一致 → x₀=1, x₁=2 → 1+2=3"
    )
    
    example(
        "異なるラベル → コミュート",
        "! x &L= &R{10, 20}; (x_0 + x_1)",
        "ラベル不一致 → 両方の組み合わせを計算"
    )
    
    example(
        "ラベルで結果を制御",
        "! a &A= &A{1, 2}; ! b &B= &B{10, 20}; ((a_0 + b_0), (a_1 + b_1))",
        "A同士、B同士が対応: (1+10, 2+20) = (11, 22)"
    )

    # =========================================================================
    section("6. 実用的パターン：データ処理")
    # =========================================================================
    
    example(
        "ペアの生成",
        "(λx.(x, (x + 1)) 5)",
        "値とその次の値のペアを作成: (5, 6)"
    )
    
    example(
        "ペアの複製と分配",
        "! p &L= (10, 20); (p_0, p_1)",
        "ペアを複製して2つのペアに"
    )
    
    example(
        "map的操作（重ね合わせ版）",
        "(λx.(x * x) &L{2, 3})",
        "リスト的な値に関数を適用: {4, 9}"
    )

    # =========================================================================
    section("7. 実用的パターン：数値計算")
    # =========================================================================
    
    example(
        "二乗計算（複製使用）",
        "! n &L= 7; (n_0 * n_1)",
        "n² = 7 * 7 = 49"
    )
    
    example(
        "平均値計算",
        "! sum &L= (10 + 20); (sum_0 / 2)",
        "合計を計算し、2で割る: 30/2=15"
    )
    
    example(
        "差と和の同時計算",
        "! a &L= 100; ! b &R= 30; ((a_0 + b_0), (a_1 - b_1))",
        "同じ値から和と差を計算: (130, 70)"
    )

    # =========================================================================
    section("8. 実用的パターン：関数プログラミング")
    # =========================================================================
    
    example(
        "カリー化",
        "((λx.λy.λz.((x + y) + z) 1) 2)",
        "3引数関数を部分適用"
    )
    
    example(
        "カリー化の完全適用",
        "(((λx.λy.λz.((x + y) + z) 1) 2) 3)",
        "1 + 2 + 3 = 6"
    )
    
    example(
        "flip（引数順序の入れ替え）",
        "((λf.λx.λy.((f y) x) λa.λb.(a - b)) 10)",
        "flip((-)) 10 = λy.(y - 10)"
    )
    
    example(
        "flip の適用",
        "(((λf.λx.λy.((f y) x) λa.λb.(a - b)) 3) 10)",
        "flip((-)) 3 10 = 10 - 3 = 7"
    )

    # =========================================================================
    section("9. 並列計算パターン")
    # =========================================================================
    
    example(
        "分岐と結合",
        "! input &L= 100; ((input_0 + 10), (input_1 * 2))",
        "入力を分岐し、異なる処理を並列実行: (110, 200)"
    )
    
    example(
        "パイプライン",
        "(λx.! t &L= (x * 2); (t_0 + t_1) 5)",
        "5 → 10(複製) → 10+10=20"
    )
    
    example(
        "Map-Reduce風",
        "! data &L= &L{1, 2}; ((data_0 * 10) + (data_1 * 10))",
        "各要素を10倍してから合計: 10+20=30"
    )

    # =========================================================================
    section("10. 最適共有の威力を示す例")
    # =========================================================================
    
    example(
        "重い計算の共有",
        "! heavy &L= (((1 + 2) + 3) + 4); ((heavy_0 * 2), (heavy_1 * 3))",
        "1+2+3+4=10 は1回だけ。結果: (20, 30)"
    )
    
    example(
        "関数適用の共有",
        "! f &L= λx.(x + x); ! r &R= (f_0 5); (r_0 + r_1)",
        "(5+5)=10 を共有して 10+10=20"
    )

    # =========================================================================
    section("11. デバッグモード例")
    # =========================================================================
    
    print("\n📝 ステップ実行の確認")
    print("   コード: ! x &L= (1 + 2); (x_0 * x_1)")
    print("   説明: 簡約過程を表示")
    print("   ---")
    result = evaluate("! x &L= (1 + 2); (x_0 * x_1)", debug=True)
    print(f"   結果: {result}")

    # =========================================================================
    section("まとめ")
    # =========================================================================
    
    print("""
    ┌────────────────────────────────────────────────────────────┐
    │  Interaction Calculus の主要概念                            │
    ├────────────────────────────────────────────────────────────┤
    │                                                            │
    │  1. ラムダ (λx.body)                                       │
    │     → 関数を定義する基本構造                               │
    │                                                            │
    │  2. 複製 (! x &L= v; t)                                    │
    │     → 値を複製して x₀, x₁ で参照                          │
    │     → 計算結果の共有に使用                                 │
    │                                                            │
    │  3. 重ね合わせ (&L{a, b})                                  │
    │     → 2つの値が同時に存在する状態                         │
    │     → 並列計算、条件分岐のモデル化                        │
    │                                                            │
    │  4. ラベル (L, R, A, B, ...)                               │
    │     → 同じラベル: DUP-SUP で消滅（ペア分解）              │
    │     → 異なるラベル: コミュート（全組み合わせ）            │
    │                                                            │
    │  5. 最適共有                                               │
    │     → ラムダ内部の計算も1回だけ実行                       │
    │     → 通常の遅延評価より効率的                            │
    │                                                            │
    └────────────────────────────────────────────────────────────┘
    """)


if __name__ == "__main__":
    main()
